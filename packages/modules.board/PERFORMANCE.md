# Профилирование производительности модуля Доски

## Обзор

Система профилирования позволяет отслеживать производительность различных операций на доске в реальном времени. Это помогает выявлять узкие места и оптимизировать работу приложения.

## Возможности

- **Отслеживание времени рендеринга** - измерение времени выполнения операций
- **Мониторинг памяти** - отслеживание использования памяти
- **Счетчики событий** - подсчет событий мыши и других взаимодействий
- **Анализ синхронизации** - измерение времени операций Yjs
- **Визуальный мониторинг** - UI для просмотра метрик в реальном времени
- **Экспорт отчетов** - сохранение данных для анализа

## Использование

### Автоматическое включение

В режиме разработки профилирование включается автоматически. В продакшене отключено по умолчанию.

### Горячие клавиши

- `F12` - показать/скрыть монитор производительности

### Глобальные функции (только в development)

```javascript
// Включить профилирование
window.__BOARD_PROFILER__.enable();

// Отключить профилирование
window.__BOARD_PROFILER__.disable();

// Получить отчет
window.__BOARD_PROFILER__.getReport();

// Очистить метрики
window.__BOARD_PROFILER__.clear();

// Получить все метрики
window.__BOARD_PROFILER__.getMetrics();

// Получить средние метрики
window.__BOARD_PROFILER__.getAverageMetrics();
```

## Отслеживаемые операции

### Рендеринг компонентов

- `render_Canvas` - рендеринг основного канваса
- `render_CanvasLayer` - рендеринг слоя с элементами
- `render_CanvasLayer_Transformer` - обновление трансформера
- `render_CanvasLayer_Elements` - рендеринг элементов доски

### Операции рисования

- `drawing_start` - начало рисования линии
- `drawing_draw` - рисование линии
- `drawing_finish` - завершение рисования
- `drawing_eraser_start` - начало стирания
- `drawing_eraser_move` - стирание
- `drawing_eraser_finish` - завершение стирания
- `drawing_text_create` - создание текста

### События мыши

- `mousedown` - нажатие кнопки мыши
- `mousemove` - движение мыши
- `mouseup` - отпускание кнопки мыши
- `wheel` - прокрутка колесика
- `drag` - перетаскивание

### Синхронизация

- `sync_local_to_yjs` - отправка изменений в Yjs
- `sync_yjs_to_local` - получение изменений из Yjs
- `sync_full_sync` - полная синхронизация

### Системные события

- `element_count_update` - изменение количества элементов
- `scale_change` - изменение масштаба
- `tool_change` - смена инструмента
- `selection_change` - изменение выделения
- `event_count_update` - обновление счетчика событий
- `periodic_update` - периодическое обновление

## Метрики

### Время рендеринга (renderTime)

Время выполнения операции в миллисекундах. Операции более 16ms считаются медленными.

### Время кадра (frameTime)

Время между кадрами. Цель - 16ms для 60fps.

### Использование памяти (memoryUsage)

Изменение использования памяти в байтах.

### Количество элементов (elementCount)

Количество элементов на доске.

### Количество событий (eventCount)

Общее количество обработанных событий.

### Время синхронизации (syncTime)

Время операций синхронизации с Yjs.

## Интерпретация результатов

### Хорошая производительность

- Среднее время рендеринга < 10ms
- Медленных операций < 5%
- Стабильное использование памяти

### Проблемы производительности

- Среднее время рендеринга > 16ms
- Медленных операций > 10%
- Постоянный рост использования памяти

### Рекомендации по оптимизации

1. **Медленный рендеринг элементов**

   - Использовать виртуализацию для больших досок
   - Оптимизировать React.memo
   - Упростить сложные компоненты

2. **Медленные операции рисования**

   - Добавить throttling для mouse events
   - Использовать requestAnimationFrame
   - Оптимизировать batchDraw

3. **Медленная синхронизация**

   - Батчить изменения
   - Оптимизировать JSON сериализацию
   - Использовать дифференциальную синхронизацию

4. **Высокое использование памяти**
   - Ограничить количество элементов
   - Очищать неиспользуемые ресурсы
   - Использовать слабые ссылки

## Примеры использования

### Отслеживание конкретной операции

```typescript
import { usePerformanceTracking } from '../hooks';

const { trackComponentRender } = usePerformanceTracking();

// Отследить рендеринг компонента
trackComponentRender('MyComponent', () => {
  // Логика рендеринга
});
```

### Отслеживание асинхронной операции

```typescript
const { trackSyncOperation } = usePerformanceTracking();

// Отследить синхронизацию
await trackSyncOperation('data_sync', async () => {
  await syncData();
});
```

### Получение отчета

```typescript
import { performanceProfiler } from '../utils/performance';

const report = performanceProfiler.generateReport();
console.log(report);
```

## Настройка

### Включение в продакшене

```typescript
// В компоненте
const { enable } = usePerformanceProfiler();

useEffect(() => {
  if (process.env.REACT_APP_ENABLE_PROFILING === 'true') {
    enable();
  }
}, [enable]);
```

### Кастомные метрики

```typescript
import { usePerformanceProfiler } from '../utils/performance';

const { updateMetrics } = usePerformanceProfiler();

// Добавить кастомную метрику
updateMetrics({ renderTime: 0, elementCount: 100 }, { action: 'custom_metric' });
```

## Мониторинг в продакшене

Для мониторинга в продакшене рекомендуется:

1. Отправлять метрики в систему мониторинга (например, Sentry, DataDog)
2. Устанавливать алерты на медленные операции
3. Анализировать тренды производительности
4. Собирать данные о пользовательских сессиях

```typescript
// Пример интеграции с внешней системой мониторинга
performanceProfiler.subscribe((data) => {
  if (data.metrics.renderTime > 100) {
    // Отправить в систему мониторинга
    analytics.track('slow_operation', {
      action: data.context.action,
      renderTime: data.metrics.renderTime,
      timestamp: data.timestamp,
    });
  }
});
```

# Оптимизация производительности модуля доски

## Обзор оптимизаций

Модуль доски включает несколько уровней оптимизации для обеспечения плавной работы с сотнями элементов:

### 1. Мемоизация компонентов

- Все основные компоненты обернуты в `React.memo`
- Хуки `useMemo` для тяжелых вычислений
- `useCallback` для обработчиков событий

### 2. Throttling событий

- Хук `useThrottle` для ограничения частоты обновлений
- Оптимизированные обработчики мыши и колеса
- Адаптивные интервалы обновления

### 3. Адаптивное качество рендеринга

- Динамическое изменение шага сетки
- Адаптивный размер точек сетки
- Оптимизация для разных масштабов

### 4. Виртуализация элементов

- Рендеринг только видимых элементов
- Простая фильтрация по позиции
- Буферизация для плавного скролла

### 5. Batch rendering

- Группировка операций отрисовки
- Оптимизированные обновления слоев
- Минимизация перерисовок

### 6. Плавная анимация

- Хук `useSmoothAnimation` для оптимизации переходов
- `requestAnimationFrame` для синхронизации с частотой обновления экрана
- Пороговые значения для предотвращения излишних обновлений
- Группировка операций рисования для лучшей производительности

## Баланс между плавностью и стабильностью

### Ключевые принципы

1. **Стабильность превыше всего**: Предотвращение дублирования слоев критически важно
2. **Плавность через оптимизацию**: Достигается через эффективные алгоритмы, а не отключение очистки
3. **Адаптивные пороги**: Обновления происходят только при значительных изменениях
4. **Правильная очистка**: `clearBeforeDraw={true}` для всех слоев

### Оптимизации без компромиссов

```typescript
// Правильно: Очистка + оптимизация
<Layer clearBeforeDraw={true}>
  <Shape
    sceneFunc={(context) => {
      // Группировка операций рисования
      context.save();
      // Рисуем элементы группами
      context.restore();
    }}
  />
</Layer>

// Неправильно: Отключение очистки для плавности
<Layer clearBeforeDraw={false}>
  // Приводит к дублированию слоев
</Layer>
```

## Новые оптимизации для плавной анимации

### useSmoothAnimation

Универсальный хук для создания плавных анимаций:

```typescript
import { useSmoothAnimation } from './hooks';

const { forceUpdate } = useSmoothAnimation(
  value,
  (newValue) => {
    // Обработка изменения значения
  },
  {
    threshold: 0.01, // Порог изменения
    throttleMs: 16, // Интервал throttling
    useRequestAnimationFrame: true, // Использовать RAF
  },
);
```

### useSmoothScale

Специализированный хук для плавного масштабирования:

```typescript
import { useSmoothScale } from './hooks';

const { forceUpdate } = useSmoothScale(scale, (newScale) => {
  // Обработка изменения масштаба
});
```

### useSmoothPosition

Специализированный хук для плавного перемещения:

```typescript
import { useSmoothPosition } from './hooks';

const { forceUpdate } = useSmoothPosition({ x, y }, (newPosition) => {
  // Обработка изменения позиции
});
```

## Решение проблем

### Проблема: Дублирование слоев при масштабировании

**Симптомы:**

- При изменении масштаба доска начинает кратно дублироваться
- Создается впечатление, что для каждого масштаба отдельный слой рендерится

**Причина:**

- Отключенная очистка слоев (`clearBeforeDraw={false}`)
- Отсутствие принудительной очистки при изменении масштаба
- Накопление старых элементов на слоях

**Решение:**

1. Включить `clearBeforeDraw={true}` для всех слоев
2. Добавить принудительную очистку при изменении масштаба
3. Использовать `context.clearRect()` в Shape для очистки области
4. Добавить `batchDraw()` для принудительного обновления

**Код решения:**

```typescript
// В BackgroundLayer
useEffect(() => {
  if (layerRef.current) {
    layerRef.current.clear();
    layerRef.current.batchDraw();
  }
}, [scale]);

// В Layer
<Layer
  ref={layerRef}
  listening={false}
  clearBeforeDraw={true} // Включаем очистку
>
```

### Проблема: Не плавная анимация при масштабировании и скролле

**Симптомы:**

- При изменении масштаба доска перерисовывается рывками
- Анимация не плавная, как будто на каждое изменение масштаба вновь перерисовывается вся доска

**Причина:**

- Полная перерисовка при каждом изменении масштаба
- Отсутствие пороговых значений для обновлений
- Неэффективная обработка событий

**Решение:**

1. Использовать пороговые значения для обновлений
2. Применять `requestAnimationFrame` для синхронизации
3. Группировать операции рисования
4. Оптимизировать виртуализацию элементов

**Код решения:**

```typescript
// Использование useSmoothScale
const { forceUpdate } = useSmoothScale(scale, (newScale) => {
  // Обработка изменения масштаба
});

// Группировка операций рисования
context.save();
// Рисуем элементы группами
context.restore();
```

### Проблема: useStage must be used within a StageProvider

**Решение:**
Используйте компонент `CanvasWithProvider` вместо `Canvas`:

```typescript
import { CanvasWithProvider } from './CanvasWithProvider';

// Вместо
<Canvas />

// Используйте
<CanvasWithProvider />
```

## Лучшие практики

### 1. Использование хуков

```typescript
// Правильно
const { scale, stagePosition } = useUIStore();
const throttledHandler = useThrottle(handler, 16);
const { forceUpdate } = useSmoothScale(scale, onScaleChange);

// Неправильно
const scale = store.getState().scale;
```

### 2. Мемоизация

```typescript
// Правильно
const memoizedValue = useMemo(() => {
  return expensiveCalculation(data);
}, [data]);

// Неправильно
const value = expensiveCalculation(data); // Вычисляется при каждом рендере
```

### 3. Обработка событий

```typescript
// Правильно
const handleClick = useCallback(
  (e) => {
    // обработка
  },
  [dependencies],
);

// Неправильно
const handleClick = (e) => {
  // обработка
}; // Создается новый обработчик при каждом рендере
```

### 4. Плавная анимация

```typescript
// Правильно
const optimizedHandler = useCallback(
  (e) => {
    requestAnimationFrame(() => {
      handleEvent(e);
    });
  },
  [handleEvent],
);

// Неправильно
const handler = (e) => {
  handleEvent(e); // Может вызывать рывки
};
```

### 5. Очистка слоев

```typescript
// Правильно: Очистка + оптимизация
<Layer clearBeforeDraw={true}>
  <Shape
    sceneFunc={(context) => {
      // Группировка операций рисования
      context.save();
      // Рисуем элементы группами
      context.restore();
    }}
  />
</Layer>

// Неправильно: Отключение очистки
<Layer clearBeforeDraw={false}>
  // Приводит к дублированию
</Layer>
```

## Мониторинг производительности

### Включение мониторинга

Нажмите `F12` для включения/выключения мониторинга производительности.

### Метрики

- Время рендеринга компонентов
- Количество перерисовок
- Использование памяти
- FPS

### Отладка

```typescript
import { usePerformanceTracking } from './hooks';

const { trackComponentRender, trackMouseEvent } = usePerformanceTracking();

// Отслеживание рендеринга
trackComponentRender('ComponentName', () => {
  // код компонента
});

// Отслеживание событий мыши
trackMouseEvent();
```

## Рекомендации по использованию

### 1. Количество элементов

- До 30 элементов: рендерим все
- 30-100 элементов: используем виртуализацию
- Более 100 элементов: требуется дополнительная оптимизация

### 2. Масштабирование

- Рекомендуемый диапазон: 0.1 - 5.0
- При масштабе < 0.01: включается дополнительная оптимизация
- При масштабе > 10: может потребоваться ограничение

### 3. События

- Используйте throttled обработчики для частых событий
- Применяйте `requestAnimationFrame` для плавной анимации
- Избегайте тяжелых вычислений в обработчиках событий
- Группируйте обновления состояния

### 4. Анимация

- Используйте `useSmoothAnimation` для плавных переходов
- Устанавливайте разумные пороговые значения
- Группируйте операции рисования
- Применяйте `batchDraw()` для множественных операций

### 5. Стабильность

- **Всегда используйте `clearBeforeDraw={true}`** для всех слоев
- Принудительно очищайте слои при изменении масштаба
- Проверяйте на отсутствие дублирования элементов
- Используйте правильную виртуализацию

## Устранение неполадок

### Высокое потребление CPU

1. Проверьте количество элементов на доске
2. Убедитесь, что включена виртуализация
3. Проверьте, не создаются ли лишние обработчики событий
4. Используйте `useSmoothAnimation` для оптимизации

### Медленная отрисовка

1. Уменьшите количество элементов
2. Проверьте настройки адаптивного качества
3. Убедитесь, что включен batch rendering
4. Применяйте группировку операций рисования

### Проблемы с масштабированием

1. **Проверьте настройки `clearBeforeDraw={true}`**
2. Убедитесь, что включена очистка при изменении масштаба
3. Проверьте, не накапливаются ли старые элементы
4. Используйте `useSmoothScale` для плавной анимации

### Дублирование слоев

1. **Убедитесь, что `clearBeforeDraw={true}` для всех слоев**
2. Проверьте, что слои очищаются при изменении масштаба
3. Используйте `layerRef.current.clear()` при необходимости
4. Проверьте, не создаются ли лишние элементы

### Не плавная анимация

1. Применяйте `requestAnimationFrame` для событий
2. Используйте пороговые значения для обновлений
3. Группируйте операции рисования
4. Оптимизируйте виртуализацию элементов

### Ошибки контекста

1. Убедитесь, что компоненты обернуты в нужные провайдеры
2. Используйте `CanvasWithProvider` вместо `Canvas`
3. Проверьте порядок провайдеров в дереве компонентов

## Заключение

Модуль доски теперь включает сбалансированные оптимизации для плавной анимации и стабильной работы:

- **Стабильность**: Правильная очистка слоев предотвращает дублирование
- **Плавное масштабирование**: Использование `useSmoothScale` и пороговых значений
- **Оптимизированная виртуализация**: Улучшенная фильтрация видимых элементов
- **Группировка операций**: Более эффективное рисование элементов
- **Синхронизация с RAF**: Плавная анимация с частотой обновления экрана
- **Адаптивные пороги**: Динамические настройки в зависимости от нагрузки

**Ключевой принцип**: Плавность достигается через эффективные алгоритмы и оптимизации, а не через отключение критически важных механизмов очистки. Стабильность работы доски всегда имеет приоритет над максимальной плавностью.

Эти оптимизации обеспечивают плавную работу доски даже с сотнями элементов и обеспечивают отличный пользовательский опыт без компромиссов в стабильности.

```typescript
// Пример интеграции с внешней системой мониторинга
performanceProfiler.subscribe((data) => {
  if (data.metrics.renderTime > 100) {
    // Отправить в систему мониторинга
    analytics.track('slow_operation', {
      action: data.context.action,
      renderTime: data.metrics.renderTime,
      timestamp: data.timestamp,
    });
  }
});
```
